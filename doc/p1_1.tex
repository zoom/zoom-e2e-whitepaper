\section{Phase I: Client Key Management}
Phase I builds out public-key driven session key negotiation for Zoom Meetings. Let's first dive into how Zoom Meetings works, and then propose changes.
\subsection{Current Design}

Each standard Zoom call is an interaction with up to 1,000 participants. Meetings are identified externally by a short meeting identifier.

Each Zoom meeting is initiated by a designated individual, who we will refer to as the host. The host has the ability to configure meetings, notify participants, select meeting passwords, and control meeting functions while a meeting is in progress. The host's configured policies (e.g., whether meeting participants may share their screens by default) are applied to the meeting. The host need not be present for the entire duration of a meeting: if ``Join Before Host'' is enabled, individuals can begin a meeting before the host joins. Similarly, a host can appoint one or more additional individuals as co-hosts and can leave the meeting under the control of a replacement host.

Each participant must possess the meeting ID as a precondition for joining a meeting. Current meeting IDs are short identifiers that must be known by the Zoom infrastructure to enable routing of data between meeting participants.

In the current system, access control to meetings is implemented via several mechanisms:

\begin{itemize*}
\item A shared meeting password, which can be selected by the host at the time the meeting is configured.
\item A ``waiting room'' feature, in which the host (and replacement host) has the ability to manually approve entry of participants throughout the course of a live meeting. Participants are identified by a name of their choosing.
\item A mechanism by which meeting participants must register prior to the meeting.
\item A setting to limit attendees of a meeting to those who are signed-in and authenticated members of certain domains.
\end{itemize*}

We retain these server-enforced access control features; they are largely orthogonal to the E2E encryption design aside from where described.

\subsection{Meeting UI Changes}

The meeting setup interface will feature a new checkbox: ``End-to-End Security.''  This bit is persisted across the scheduling system, and cannot be unset once the meeting starts. When checked, the behavior of the meeting changes in several key ways:

\begin{itemize*}
\item The ``Enable Join Before Host'' checkbox becomes grayed out and deselected.
\item All participating clients must run the official Zoom client software; those on dial-ins, web browsers, or legacy Zoom-enabled devices are locked out of the meeting.
\item The Cloud Recording feature becomes disabled.
\end{itemize*}

Once the meeting starts, there are other important UI changes:

\begin{itemize*}
\item All participants will receive a clear indication of the security level of every meeting.
\item They can see a ``meeting leader security code'' that they can use to verify that no one's connection to the meeting was intercepted. The host can read this code out loud, and all participants can check that their clients display the same code.


\end{itemize*}

\subsection{A Basic E2E Key Agreement Proposal}

All meeting content sent between Zoom clients is currently encrypted using a ``meeting key'' that is distributed by the Zoom infrastructure. This key is pluralized into a set of per-client/per-stream encryption keys, which are then used to encrypt A/V and chat streams sent to other clients via Zoom's infrastructure. After the initial key sharing (and excluding value-added services such as Cloud Recording and PSTN) Zoom's infrastructure servers do not require knowledge of this key.

The goal of the new design, therefore, is simply to eliminate Zoom's role in distributing this initial shared meeting key material, and to shift this responsibility to the participating Zoom clients.

In the revised approach, all keys will be generated and distributed between individual authorized meeting participants that run the Zoom client software. No secret key material or unencrypted meeting contents will be provided to Zoom infrastructure servers, except in specific cases where this sharing is explicitly authorized by a meeting host (e.g., to support abuse reporting.)

\subsection{System Components}
\label{subsec:comp}

The system assumes the following components:
\begin{description}
\item {\bf Identity management system.} The revised system depends on the existence of a Zoom ID management system that will be responsible for distributing cryptographic public keys generated by individual clients. This server will bind keys to Zoom user accounts where possible, and will also support clients who do not have explicit Zoom identities.

\item {\bf Signaling channel.} The system will make use of a reliable signaling channel to distribute cryptographic messages between participants in a meeting. Currently, meeting participants route control messages on TLS-tunnels over TCP, through the MMRs. TLS is terminated at Zoom's servers. This channel is suitable for our needs.

\item {\bf Bulletin board.} Participants in the channel can post cryptographic messages to a meeting-specific ``bulletin board'', where all other participants can see them. This abstraction can be implemented over the signaling channel. The server controls the bulletin board, as it controls the signaling channel itself and therefore can tamper with it.

\item {\bf Meeting leader.} The protocol overview requires that, at all times, one authorized Zoom client will be present in a meeting and considered the meeting ``leader''. This client will have the responsibility of generating the shared meeting key, authorizing new meeting participants, kicking out unwanted participants, and distributing keys. For Phase I, this leader will be the meeting host, and will fall back to the co-host with the lowest user ID if the current host leaves. In future phases, we will relax this assumption (and therefore re-enable ``Join Before Host'').

\end{description}

\subsection{Cryptographic Algorithms}

All meeting data sent over UDP gets encrypted with AES in GCM mode~\cite{sp80038d}.
%
Key derivation uses the HKDF algorithm~\cite{rfc5869}.
%
For public key encryption and signing, we rely on Diffie-Hellman over Curve25519~\cite{bernstein2006curve25519} and EdDSA over Ed25519~\cite{eddsa}.
%
We use the interface and implementation of the NaCl~\cite{nacl}-inspired \sodium{} library~\cite{libsodium}, as detailed below.

\subsubsection{Signing}

For signing, we use \sodium 's EdDSA implementation directly:
%
\begin{itemize*}
   \item $\zoomsignkeygen$ generates a keypair $(\vkzoomsign, \skzoomsign)$ (via \texttt{crypto\_sign\_keypair}).
   \item $\zoomsignsign$ takes as input a message $M$ and outputs a ``detached'' signature
   $\signaturezoomsign$ over $M$ (via \texttt{crypto\_sign\_detached}).
   \item $\zoomsignverify$ takes as input a detached signature $\signaturezoomsign$ and a message $M$; it outputs $\true$ on verification success
   and $\false$ on failure (via \texttt{crypto\_sign\_verify\_detached}).
\end{itemize*}

\subsubsection{Authenticated Public-Key Encryption}

Authenticated public-key encryption uses \sodium 's \texttt{crypto\_box}
interface:

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX KEYGEN
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxkeygen}}\\
{\bf Input:} None \\
{\bf Output:} an encryption keypair $(\pkbox, \skbox)$ \\

\vspace{-1.5em}
To generate a keypair:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Return $(\pkbox, \skbox)$ as generated by \texttt{crypto\_box\_keypair}.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX ENCRYPT
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxencrypt}} \\
{\bf Input:} Sender's secret key $\skboxS$ and receiver's public key $\pkboxR$, metadata $\metadata \in \{0,1\}^{*}$, and a message $M \in \{0,1\}^{*}$. \\
{\bf Output:} a ciphertext $\ciphertext$ \\

\vspace{-1.5em}
To encrypt:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Generate a 192-bit random string $\randomNonce$.
\item Compute $K \leftarrow \texttt{crypto\_box\_beforenm}(\pkboxR, \skboxS)$, which is the DH key-exchange of the public key $\pkboxR$ and the private key $\skboxS$.
\item Compute $K' \leftarrow \HKDF(K, \metadata)$.
\item Compute $C' \leftarrow \texttt{crypto\_box\_afternm}(M, \randomNonce, K')$, which computes XSalsa20/Poly-1305 over the plaintext $M$ with the symmetric key $K'$ and the nonce $\randomNonce$.
\item Output $C \leftarrow (C', \randomNonce)$.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX DECRYPT
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxdecrypt}} \\
{\bf Input:} Receiver's secret key $\skboxR$ and sender's public key $\pkboxS$, metadata $\metadata$ and a ciphertext $\ciphertext$. \\
{\bf Output:} a message $M$, or ${\sf error}$

To decrypt:

\vspace{-1em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Parse $\ciphertext$ as $(C', \randomNonce)$.
\item Compute $K \leftarrow \texttt{crypto\_box\_beforenm}(\pkboxS, \skboxR)$.
\item Compute $K' \leftarrow \HKDF(K, \metadata)$.
\item Compute $M \leftarrow \texttt{crypto\_box\_open\_afternm}(C', \randomNonce, K')$. If decryption fails, output $\errorSym$. Otherwise output $M$.
\end{enumerate*}
\endgroup

\subsection{Long-term Key Management}

When user $i$ signs up, or upgrades their Zoom application to the first version that supports E2E as described in this proposal, their client generates a long-term signing keypair:

\[
(\ivk_i, \isk_i) \leftarrow \zoomsignkeygen()
\]

The Zoom client posts the mapping $\langle (i, \deviceid) \rightarrow \ivk_i \rangle$ to the server, signed with $\zoomsignsign$ under $\isk_i$. This self-signed binding becomes available to those who join user $i$ in meetings.

The client will persist this keypair indefinitely on this device and secure $\isk_i$ using whatever mechanisms the local hardware and operating system provide. Of course, $\isk_i$ never leaves the device and must be excluded from any cloud backups.

A device may lose its long-term key after an OS reinstall, a disk corruption, an app reinstall on mobile, and so on. In this case, it appears to the system as a new device and goes through the provisioning process as a new device would.

The specifics for client storage of long-term keys are detailed in Section~\ref{subsec:lks}.

\subsection{Join/Leave Protocol flow}
We assume each meeting is identified by its unique $\meetingID$, as in the current system. Each meeting gets its own ``bulletin board'' that's accessible to everyone who has server-gated access to the meeting. The server clears it when the meeting ends. Note that meetings can be ended then later restarted, and a meeting ID can refer to a standing or repeating meeting.

From a cryptographic perspective, the server is free to tamper with all values posted on the bulletin board. In Section~\ref{subsec:secprop}, we describe further that a malicious server that sends stale messages from a previous meeting incarnation can at best deny service, which it can do regardless.

\subsubsection{Participant Key Generation}
When any participant $i$ joins the meeting, whether before or after it starts, and whether the leader or not, it performs the following operations:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Generates new public-key \textit{ephemeral} encryption keypair: $(\pk_i, \sk_i) = \cboxkeygen()$.
\item Queries the Zoom infrastructure for the server-generated $\meetingUUID$ for this instance of this meeting; this is server-generated per-meeting-instance randomness that the individual participants cannot control.
\item Computes $\binding_i \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| i \allowbreak \| \deviceid \| \ivk_i \| \allowbreak \pk_i \right)$.
\item Computes $\sig_i \leftarrow \zoomsignsign(\isk_i, \texttt{"Zoom00EPubKeys\textbackslash0"} \| \allowbreak \binding_i)$.
\item Stores $\sk_i$ for the duration of the meeting.
\item Posts $\sig_i$ to the bulletin board, so that all participants can see it.
\end{enumerate*}
\endgroup

\subsubsection{Leader Join}

When the leader joins the meeting $\meetingID$, it:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\meetingUUID$ from the Zoom infrastructure.
\item Generates a symmetric 32-byte seed $\mk$ using a secure random number generator.
\item Computes the meeting key as $\MK \leftarrow \HKDF(\mk, \allowbreak \texttt{"Zoom00SKey\textbackslash0"} \|  \allowbreak \meetingID \|  \allowbreak \meetingUUID)$.
\item Gets the full list of participants $\participantList$ from the MMR.
\item For each participant $i \in \participantList$, it runs the ``Participant Join (Leader)'' subroutine for $i$.
\end{enumerate*}
\endgroup

\subsubsection{Participant Join (Leader)}

Given a leader $\LL$ and a participant $i$ joining meeting $\meetingID$ on $\deviceid$, the leader:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\ivk_i$ from the key server.
\item Fetches $\sig_i$ from the meeting's ``bulletin board''.
\item Computes $\binding_i \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| i \allowbreak \| \deviceid \| \ivk_i \| \allowbreak \pk_i \right)$.
\item Verifies the signature: $\zoomsignverify(\ivk_i, \sig_i, \allowbreak \texttt{"Zoom00EPubKeys\textbackslash0"} \| \allowbreak \binding_i)$.
\item If verification fails, it aborts.
\item Computes $\metadata \leftarrow \left( \texttt{"Zoom00SDKey\textbackslash0"}  \| \meetingID \| \allowbreak \meetingUUID \| \allowbreak \LL \| i \right)$.
\item Computes $\ciphertext \leftarrow \cboxencrypt(\sk_\LL, \pk_i, \metadata, \mk)$.
   \label{participantJoinRekeyStart}
\item Posts $(i, \ciphertext)$ to the ``bulletin board''.
   \label{participantJoinRekeyEnd}
\end{enumerate*}
\endgroup

\subsubsection{Participant Join (Non-Leader)}

When participant $i$ joins meeting $\meetingID$, it performs the reverse of the above procedure:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\ivk_{\LL}$ from the Key server for the leader $\LL$.
\item Fetches $\sig_{\LL}$ and $\pk_\LL$ from the meeting's ``bulletin board''.
\item Fetches $(i, \ciphertext_i)$ from the ``bulletin board''.
\item Fetches the $\meetingUUID$ from the server.
\item Computes $\binding_\LL \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| \LL \allowbreak \| \deviceid \| \ivk_\LL \| \allowbreak \pk_\LL \right)$.
\item Verifies the signature: $\zoomsignverify(\ivk_{\LL}, \sig_\LL, \texttt{"Zoom00EPubKeys\textbackslash0"} \|\allowbreak \binding_\LL)$.
\item If verification fails, it aborts.
\item Computes $\metadata \leftarrow \left(\texttt{"Zoom00SDKey\textbackslash0"} \| \allowbreak \meetingID \| \allowbreak \meetingUUID \| \allowbreak \LL \| i \right)$.
\item Decrypts $\mk \leftarrow \cboxdecrypt(\sk_{i}, \pk_{\LL}, \metadata \allowbreak, \ciphertext)$.
   \label{participantJoinRekeyNonLeaderStart}
\item If decryption outputs {\sf error}, it aborts.
\item Computes the meeting key as $\MK \leftarrow \HKDF(\mk, \texttt{"Zoom00SKey\textbackslash0"} \| \allowbreak \meetingID \|  \allowbreak \meetingUUID)$.
   \label{participantJoinRekeyNonLeaderEnd}
\end{enumerate*}
\endgroup

Now all participants have access to the shared meeting key $\MK$, and can encrypt and decrypt meeting streams accordingly.
